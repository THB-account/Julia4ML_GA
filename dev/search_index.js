var documenterSearchIndex = {"docs":
[{"location":"selection/#Selection","page":"Selection","title":"Selection","text":"","category":"section"},{"location":"selection/","page":"Selection","title":"Selection","text":"Let there be documentation on selection.","category":"page"},{"location":"selection/","page":"Selection","title":"Selection","text":"roulette_wheel\ntournament_selection\nrank_selection","category":"page"},{"location":"selection/#Julia4ML_GA.roulette_wheel","page":"Selection","title":"Julia4ML_GA.roulette_wheel","text":"roulette_wheel(fitness, selection_number, rng)\n\nImplements a simple roulette_wheel. If the sum over positive fitness scores is larger than the sum  over negative scores, higher fitness scores are more likely to be selected, otherwise negative values are more likely to be selected. Should only be used if either all fitness values are negative or all fitness values are  positive\n\nfitness: (Vector{<:Real}) Vector of fitness values. The higher the absolute fitness,  the more likely the corresponding gene is selected.\nselection_number: (Integer) Indicates how many indices are returned.\nrng: Instance of a random number generator to produce reproducible results.\n\nReturns indices of selected populants.\n\n\n\n\n\n","category":"function"},{"location":"selection/#Julia4ML_GA.tournament_selection","page":"Selection","title":"Julia4ML_GA.tournament_selection","text":"tournament_selection(fitness, selection_number, tournament_size, rng)\n\nImplements a simple tournament selection. Selects selection_number candidates. Each candidate is selected by taking  the fittest of tournament_size randomly chosen candidates. \n\nfitness: (Vector{<:Real}) Vector of fitness values.\nselection_number: (Integer) Indicates how many indices are returned.\nrng: Instance of a random number generator to produce reproducible results.\n\nReturns indices of selected populants.\n\n\n\n\n\n","category":"function"},{"location":"selection/#Julia4ML_GA.rank_selection","page":"Selection","title":"Julia4ML_GA.rank_selection","text":"rank_selection(fitness, selection_number, rng)\n\nImplements rank selection based on roulette_wheel. Can deal with mixed positive and negative values. Selects based on order of fitness values. The amount of the difference between the fitness values is not taken into account.\n\nfitness: (Vector{<:Real}) Vector of fitness values. The lower the fitness,  the more likely the corresponding gene is selected.\nselection_number: (Integer) Indicates how many indices are returned.\nrng: Instance of a random number generator to produce reproducible results.\nf: Function which can be used to change importance of rank. If x -> x^2 is used, the gene with higher fitness is returned with higher probability.\n\nReturns indices of selected populants.\n\n\n\n\n\n","category":"function"},{"location":"termination/#Termination-Criteria","page":"Termination Criteria","title":"Termination Criteria","text":"","category":"section"},{"location":"termination/","page":"Termination Criteria","title":"Termination Criteria","text":"For the package are three different criteria available: Number of iterations, time limit and a lower bound. All three can be specified in the optimize function via the keyword arguments iterations, time_limit and obj_bound.","category":"page"},{"location":"termination/","page":"Termination Criteria","title":"Termination Criteria","text":"They are optional and can be used in combination. Whichever of the three applies first will terminate the optimization loop and the results will be returned. If none of the criteria is set the optimization process will not be started and and error will be thrown. In case both iterations and time_limit are not set a warning is raised, that a lower bound may never be reached.","category":"page"},{"location":"termination/#Number-of-iterations","page":"Termination Criteria","title":"Number of iterations","text":"","category":"section"},{"location":"termination/","page":"Termination Criteria","title":"Termination Criteria","text":"With this setting the optimization process will have at most iterations optimization steps. An integer number is expected.","category":"page"},{"location":"termination/#Time-limit","page":"Termination Criteria","title":"Time limit","text":"","category":"section"},{"location":"termination/","page":"Termination Criteria","title":"Termination Criteria","text":"The keyword argument time_limit expects a float as time in seconds. With this setting execution time is checked after each optimization step. ","category":"page"},{"location":"termination/#Lower-bound","page":"Termination Criteria","title":"Lower bound","text":"","category":"section"},{"location":"termination/","page":"Termination Criteria","title":"Termination Criteria","text":"With this argument the lower bound for the objective function value is set.  If the fittest populant reaches an objective value lower or equal than the bound the algorithm finishes. Note that only setting this criterium may result in infinite loops.","category":"page"},{"location":"mutation/#Mutation","page":"Mutation","title":"Mutation","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"Let there be documentation on mutation.","category":"page"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"displacement\ngaussian_displacement\nunivariate_displacement\nbit_inversion","category":"page"},{"location":"mutation/#Julia4ML_GA.displacement","page":"Mutation","title":"Julia4ML_GA.displacement","text":"displacement(genes, rng)\n\nImplements the displacement method. The genes are displaced inside itself.  The returned element has the same values as before, but with scrambled genes. Should only be used if the sequence of the genes solve the problem (tsp). Should not be used for numerical problem.\n\ngenes: ::Vector{<:Real} containing all genes.\nrng: Instance of a random number generator to produce reproducible results.\n\nReturns resulting genes.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Julia4ML_GA.gaussian_displacement","page":"Mutation","title":"Julia4ML_GA.gaussian_displacement","text":"gaussian_displacement(genes, rng)\n\nAdds gaussian noise to the genes with mathcalN(01).  Should be used for numerical problems (rosenbrock). Should not be used for integer value problems (tsp).\n\nrng: Instance of a random number generator to produce reproducible results.\ngenes: (Vector{Float64}) Vector containing all genes.\n\nReturns resulting gene.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Julia4ML_GA.univariate_displacement","page":"Mutation","title":"Julia4ML_GA.univariate_displacement","text":"univariate_displacement(gene, rng)\n\nAdds univeriate noise to the gene with mathcalU(-11). Should be used for numerical problems (rosenbrock). Should not be used for integer value problems (tsp).\n\nrng: Instance of a random number generator to produce reproducible results.\ngene: (Vector{Float64}) Vector containing all genes.\n\nReturns resulting gene.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Julia4ML_GA.bit_inversion","page":"Mutation","title":"Julia4ML_GA.bit_inversion","text":"bit_inversion(genes, rng)\n\nInverses each bit with probability 1/length(genes). Should only be used if genes is a Bool Vector.\n\nrng: Instance of a random number generator to produce reproducible results.\ngenes: (Vector{Bool}) Vector containing all genes.\n\nReturns resulting genes.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Crossover","page":"Crossover","title":"Crossover","text":"","category":"section"},{"location":"crossover/","page":"Crossover","title":"Crossover","text":"Let there be documentation on Crossover.","category":"page"},{"location":"crossover/","page":"Crossover","title":"Crossover","text":"k_point\npartially_mapped","category":"page"},{"location":"crossover/#Julia4ML_GA.k_point","page":"Crossover","title":"Julia4ML_GA.k_point","text":"k_point(genes1, genes2, rng)\n\nImplements the k point crossover method.  genes1 and genes2 are used to create child1 and child2, which are returned.  child1 is a copy of genes1 up to randomly generated crossover point.  After that it is a copy of genes2. The same for child2 respectively with parent roles swapped. If more than one crossover point exist this procedure is repeated. If k == 1, this is single point crossover.\n\ngenes1, genes2: Vector{<:Real} containing all genes of a each parent.\nrng: An instance of a random number generator to produce reproducible results.\nk: Number of cross over points\n\nReturns child1 and child2\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Julia4ML_GA.partially_mapped","page":"Crossover","title":"Julia4ML_GA.partially_mapped","text":"partially_mapped(genes1, genes2,rng)\n\nImplements the partially mapped crossover (PMX) method.  genes1 and genes2 are used to create child1 and child2, which are returned. This procedure only changes the order of the genes. child1, child2, genes1 and genes2 all have the same genes, but the order can be different.\n\ngenes1, genes2: Vector{<:Real} containing all genes of each parent.\nrng: An instance of a random number generator to produce reproducible results.\n\nReturns child1 and child2\n\n\n\n\n\n","category":"function"},{"location":"reference/#Julia4ML_GA-API","page":"API Reference","title":"Julia4ML_GA API","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Julia4ML_GA]","category":"page"},{"location":"reference/#Julia4ML_GA.GeneticAlgorithm","page":"API Reference","title":"Julia4ML_GA.GeneticAlgorithm","text":"Contains information and functions to execute an optimization process for a genetic algorithm.\n\npopulation_size: (Integer) Number of populants to be maintained.\neliteSize: (Integer) Number of populants selected as elite.\ncrossoverRate: (Float) Probability of crossover for two populants.\nmutationRate: (Float) Probability of mutation.\nselection: (Function) Function to select populants for next iteration.\nmuation: (Function) Mutation function.\ncrossover: (Function) Crossover function.\n\nConstructor:\n\nGeneticAlgorithm(;\n    populationSize=50,\n    eliteSize=5,\n    crossoverRate=0.8,\n    mutationRate=0.1,\n    selection=roulette_wheel,\n    mutation=displacement,\n    crossover=k_point\n)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Julia4ML_GA.GeneticAlgorithmState","page":"API Reference","title":"Julia4ML_GA.GeneticAlgorithmState","text":"State of a genetic algorithm.\n\npopulation: (Vector) Current population. Vector conatining elements of same type as starting point for optimization process.\npopulationFitness: (Function) Fitness function by which the population's fitness is to be evaluated.\n\nConstructor:\n\nGeneticAlgorithmState(population,objective)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Julia4ML_GA.OptimizationResult","page":"API Reference","title":"Julia4ML_GA.OptimizationResult","text":"Contains the results of a evolutionary optimization process\n\nminimalPopulant: (T1) Populant that minimizes the objective.\nminimalFitness: (T2) Value of the objective for the minimal populant.\ntrace: (OptimizationTrace) Trace object containing individual values of generations.\n\nConstructor:\n\nOptimizationResult(minimalPopulant,minmalFitness,trace)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Julia4ML_GA.OptimizationTrace","page":"API Reference","title":"Julia4ML_GA.OptimizationTrace","text":"Contains information and functions to execute an optimization process for a genetic algorithm.\n\npopulations: (Vector{Vector{Vector{Real}}}) Population of each iteration.\nfitnessValues: (Vector{Vector{Real}}) Fitness values of each generation.\nfittestPopulants: (Vector{Vector{Real}}) Fittest Individual of each population.\n\nConstructor:\n\nOptimizationTrace()\n\n\n\n\n\n","category":"type"},{"location":"reference/#Julia4ML_GA.Terminator","page":"API Reference","title":"Julia4ML_GA.Terminator","text":"Holds information about termination criteria. Starts timer upon creation, if a timelimit is provided.\n\nmax_iterations: (Integer/NaN) Maximum number of iterations in optimisation process. Default is NaN.\ntime_limit: (Float/NaN) Time after which the optimization should be terminated. Default is NaN.\nobj_bound: (Float/NaN) Threshold after which the optimization should be terminated. Default is NaN.\n\nThrows \n\nArgumentError if no termination condition is set.\nWarning if no time or iteration limit is provided.\n\nConstructor:\n\nTerminator(;max_iter=NaN, time_limit=NaN, obj_bound=NaN)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Julia4ML_GA.append!-Tuple{Julia4ML_GA.AbstractTrace, Julia4ML_GA.AbstractState}","page":"API Reference","title":"Julia4ML_GA.append!","text":"append!(trace,state)\n\nInitialises populant's genes.\n\ntrace: (AbstractTrace) Trace struct containing values\nstate: (AsbtractState) A state of a genetic algorithm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.argmin-Tuple{Julia4ML_GA.OptimizationResult}","page":"API Reference","title":"Julia4ML_GA.argmin","text":"argmin(res)\n\nres: (OptimizationResult)\n\nReturns minimizing gene\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.bit_inversion-Union{Tuple{R}, Tuple{Vector{Bool}, R}} where R<:Random.AbstractRNG","page":"API Reference","title":"Julia4ML_GA.bit_inversion","text":"bit_inversion(genes, rng)\n\nInverses each bit with probability 1/length(genes). Should only be used if genes is a Bool Vector.\n\nrng: Instance of a random number generator to produce reproducible results.\ngenes: (Vector{Bool}) Vector containing all genes.\n\nReturns resulting genes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.crossover!-Union{Tuple{R}, Tuple{A}, Tuple{A, A, Vector{Int64}, Julia4ML_GA.GeneticAlgorithm, R}} where {A<:AbstractArray, R<:Random.AbstractRNG}","page":"API Reference","title":"Julia4ML_GA.crossover!","text":"crossover!(parents,children,selected_individuals,ga,rng)\n\nControl function for crossover.\n\nparents: (Vector) (Sub-)Population to be used to create offspring.\nchildren (Vector) Object to hold the newly created offspring.\nselected_individuals: (Vector{Integer}) The for crossover selected populant's indices.\nga: (GeneticAlgorithm) GeneticAlgorithm instance the population is part of.\nrng:  Instance of a random number generator to produce reproducible results.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.displacement-Union{Tuple{R}, Tuple{Vector{var\"#s17\"} where var\"#s17\"<:Real, R}} where R<:Random.AbstractRNG","page":"API Reference","title":"Julia4ML_GA.displacement","text":"displacement(genes, rng)\n\nImplements the displacement method. The genes are displaced inside itself.  The returned element has the same values as before, but with scrambled genes. Should only be used if the sequence of the genes solve the problem (tsp). Should not be used for numerical problem.\n\ngenes: ::Vector{<:Real} containing all genes.\nrng: Instance of a random number generator to produce reproducible results.\n\nReturns resulting genes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.evaluation!-Union{Tuple{F}, Tuple{Julia4ML_GA.GeneticAlgorithmState, F}} where F<:Function","page":"API Reference","title":"Julia4ML_GA.evaluation!","text":"evaluation!(ga,state,objective)\n\nControl function for fitness evaluation.\n\nga: (GeneticAlgorithm) GeneticAlgorithm instance to work on.\nstate:  (GeneticAlgorithmState) GeneticAlgorithmState instance to proceed from.\nobjective: (Function) Fitness function by which the population is evaluated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.gaussian_displacement-Union{Tuple{R}, Tuple{Vector{var\"#s17\"} where var\"#s17\"<:Real, R}} where R<:Random.AbstractRNG","page":"API Reference","title":"Julia4ML_GA.gaussian_displacement","text":"gaussian_displacement(genes, rng)\n\nAdds gaussian noise to the genes with mathcalN(01).  Should be used for numerical problems (rosenbrock). Should not be used for integer value problems (tsp).\n\nrng: Instance of a random number generator to produce reproducible results.\ngenes: (Vector{Float64}) Vector containing all genes.\n\nReturns resulting gene.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.get_sub_vector","page":"API Reference","title":"Julia4ML_GA.get_sub_vector","text":"get_sub_vector(vec, s, e, allow_wrap)\n\nReturns a part of the vector. \n\nvec: Vector{<:Real}\ns: Start Index (including) [1, length]\ne: End index (not including) [2, length + 1]\nallow_wrap: If true, start can be behind end\n\n\n\n\n\n","category":"function"},{"location":"reference/#Julia4ML_GA.initialise_genetic_state-Union{Tuple{R}, Tuple{F}, Tuple{Vector{Float64}, F, Julia4ML_GA.GeneticAlgorithm, R}} where {F<:Function, R<:Random.AbstractRNG}","page":"API Reference","title":"Julia4ML_GA.initialise_genetic_state","text":"initialise_genetic_state(starting_point,objective,ga,rng)\n\nInitialises populant's genes.\n\nstarting_point: (Vector{Float64})\nobjective: (Function) Fitness function to be used.\nga: (GeneticAlgorithm) GeneticAlgorithm instance to work on.\nrng: Instance of a random number generator to produce reproducible results.\n\nReturns GeneticAlgorithmState.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.k_point-Union{Tuple{R}, Tuple{Vector{var\"#s15\"} where var\"#s15\"<:Real, Vector{var\"#s16\"} where var\"#s16\"<:Real, R}, Tuple{Vector{var\"#s17\"} where var\"#s17\"<:Real, Vector{var\"#s18\"} where var\"#s18\"<:Real, R, Int64}} where R<:Random.AbstractRNG","page":"API Reference","title":"Julia4ML_GA.k_point","text":"k_point(genes1, genes2, rng)\n\nImplements the k point crossover method.  genes1 and genes2 are used to create child1 and child2, which are returned.  child1 is a copy of genes1 up to randomly generated crossover point.  After that it is a copy of genes2. The same for child2 respectively with parent roles swapped. If more than one crossover point exist this procedure is repeated. If k == 1, this is single point crossover.\n\ngenes1, genes2: Vector{<:Real} containing all genes of a each parent.\nrng: An instance of a random number generator to produce reproducible results.\nk: Number of cross over points\n\nReturns child1 and child2\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.min-Tuple{Julia4ML_GA.OptimizationResult}","page":"API Reference","title":"Julia4ML_GA.min","text":"min(res)\n\nres: (OptimizationResult)\n\nReturns minimal fitness value\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.mutation!-Union{Tuple{R}, Tuple{A}, Tuple{A, Julia4ML_GA.GeneticAlgorithm, R}} where {A<:AbstractArray, R<:Random.AbstractRNG}","page":"API Reference","title":"Julia4ML_GA.mutation!","text":"mutation!(offspring,ga,rng)\n\ncontrol function for mutation.\n\npopulation: (Vector) (Sub-)Population to be mutated.\nga: (GeneticAlgorithm) GeneticAlgorithm instance the population is part of.\nrng: Instance of a random number generator to produce reproducible results.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.optimize-Union{Tuple{F}, Tuple{R}, Tuple{A}, Tuple{A, F, Julia4ML_GA.GeneticAlgorithm}} where {A<:AbstractArray, R<:Random.AbstractRNG, F<:Function}","page":"API Reference","title":"Julia4ML_GA.optimize","text":"optimize(starting_point,objective,ga::GeneticAlgorithm;iterations=100,rng=default_rng())\n\nExecutes optimization process\n\nstarting_point: (Vector) Initial candidate.\nga: (GeneticAlgorithm)\nobjective: (Function) Fitness function to evaluate population. \niterations: (Integer) Maximum number of iterations. Termination condition, defaults to 100.\ntime_limit: (Float) Time limit in seconds. Termination condition, defaults to NaN.\nobj_bound : (Float) Lower bound to objective value. Termination condition, defaults to NaN.\nrng: Instance of a random number generator to produce reproducible results. Default is Random.default_rng().\n\nReturns final population's fittest populant.\n\nPopulation is initialized and build.  Then the optimization is executed using the provided fitness function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.partially_mapped-Tuple{Vector{var\"#s15\"} where var\"#s15\"<:Real, Vector{var\"#s14\"} where var\"#s14\"<:Real, Any}","page":"API Reference","title":"Julia4ML_GA.partially_mapped","text":"partially_mapped(genes1, genes2,rng)\n\nImplements the partially mapped crossover (PMX) method.  genes1 and genes2 are used to create child1 and child2, which are returned. This procedure only changes the order of the genes. child1, child2, genes1 and genes2 all have the same genes, but the order can be different.\n\ngenes1, genes2: Vector{<:Real} containing all genes of each parent.\nrng: An instance of a random number generator to produce reproducible results.\n\nReturns child1 and child2\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.rank_selection-Union{Tuple{F}, Tuple{R}, Tuple{Vector{var\"#s16\"} where var\"#s16\"<:Real, Int64, R}, Tuple{Vector{var\"#s15\"} where var\"#s15\"<:Real, Int64, R, F}} where {R<:Random.AbstractRNG, F<:Function}","page":"API Reference","title":"Julia4ML_GA.rank_selection","text":"rank_selection(fitness, selection_number, rng)\n\nImplements rank selection based on roulette_wheel. Can deal with mixed positive and negative values. Selects based on order of fitness values. The amount of the difference between the fitness values is not taken into account.\n\nfitness: (Vector{<:Real}) Vector of fitness values. The lower the fitness,  the more likely the corresponding gene is selected.\nselection_number: (Integer) Indicates how many indices are returned.\nrng: Instance of a random number generator to produce reproducible results.\nf: Function which can be used to change importance of rank. If x -> x^2 is used, the gene with higher fitness is returned with higher probability.\n\nReturns indices of selected populants.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.roulette_wheel-Union{Tuple{R}, Tuple{Vector{var\"#s16\"} where var\"#s16\"<:Real, Int64, R}} where R<:Random.AbstractRNG","page":"API Reference","title":"Julia4ML_GA.roulette_wheel","text":"roulette_wheel(fitness, selection_number, rng)\n\nImplements a simple roulette_wheel. If the sum over positive fitness scores is larger than the sum  over negative scores, higher fitness scores are more likely to be selected, otherwise negative values are more likely to be selected. Should only be used if either all fitness values are negative or all fitness values are  positive\n\nfitness: (Vector{<:Real}) Vector of fitness values. The higher the absolute fitness,  the more likely the corresponding gene is selected.\nselection_number: (Integer) Indicates how many indices are returned.\nrng: Instance of a random number generator to produce reproducible results.\n\nReturns indices of selected populants.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.terminate!-Tuple{Julia4ML_GA.Terminator, Julia4ML_GA.GeneticAlgorithmState}","page":"API Reference","title":"Julia4ML_GA.terminate!","text":"terminate(t::Terminator, state::GeneticAlgorithmState)\n\nEvaluates configured termination criteria.\n\nt: (Terminator) contains termination criteria\nstate: (GeneticAlgorithmState)\n\nReturns false if algorithm should terminate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.tournament_selection-Union{Tuple{R}, Tuple{Vector{var\"#s15\"} where var\"#s15\"<:Real, Int64, Int64, R}} where R<:Random.AbstractRNG","page":"API Reference","title":"Julia4ML_GA.tournament_selection","text":"tournament_selection(fitness, selection_number, tournament_size, rng)\n\nImplements a simple tournament selection. Selects selection_number candidates. Each candidate is selected by taking  the fittest of tournament_size randomly chosen candidates. \n\nfitness: (Vector{<:Real}) Vector of fitness values.\nselection_number: (Integer) Indicates how many indices are returned.\nrng: Instance of a random number generator to produce reproducible results.\n\nReturns indices of selected populants.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.trace-Tuple{Julia4ML_GA.OptimizationResult}","page":"API Reference","title":"Julia4ML_GA.trace","text":"trace(res)\n\nres: (OptimizationResult)\n\nReturns trace of evolutionary algorithm\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.univariate_displacement-Union{Tuple{R}, Tuple{Vector{var\"#s17\"} where var\"#s17\"<:Real, R}} where R<:Random.AbstractRNG","page":"API Reference","title":"Julia4ML_GA.univariate_displacement","text":"univariate_displacement(gene, rng)\n\nAdds univeriate noise to the gene with mathcalU(-11). Should be used for numerical problems (rosenbrock). Should not be used for integer value problems (tsp).\n\nrng: Instance of a random number generator to produce reproducible results.\ngene: (Vector{Float64}) Vector containing all genes.\n\nReturns resulting gene.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Julia4ML_GA.update_state!-Union{Tuple{F}, Tuple{R}, Tuple{Julia4ML_GA.GeneticAlgorithm, Julia4ML_GA.GeneticAlgorithmState, F, R}} where {R<:Random.AbstractRNG, F<:Function}","page":"API Reference","title":"Julia4ML_GA.update_state!","text":"update_state!(ga, state, objective, rng)\n\nUpdates GeneticAlgorithmState according to provided GeneticAlgorithm instance. Selection, crossover, mutation and evaluation is executed. Equivalent to one iteration of the optimizatrion process.\n\nga: (GeneticAlgorithm) GeneticAlgorithm instance to work on.\nstate: (GeneticAlgorithmState) GeneticAlgorithmState to proceed from.\nobjective: (Function) Fitness function to be used.\nrng: Instance of a random number generator to produce reproducible results.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Julia4ML_GA","category":"page"},{"location":"#Julia4ML_GA","page":"Home","title":"Julia4ML_GA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia4ML_GA is a package for genetic algorithms.","category":"page"},{"location":"#What-is-a-genetic-algorithm","page":"Home","title":"What is a genetic algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Genetic algorithms solve optimization problems by","category":"page"},{"location":"","page":"Home","title":"Home","text":"creating a population of candidate solutions, each with their own genomes\nevaluating them with a fitness function and iteratively selecting only the best candidates\nmaintaining the population size by creating new populants via crossover between successful populants\nmutating populants in random places of their genome","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Genetic Algorithm Loop)","category":"page"},{"location":"#Basic-example","page":"Home","title":"Basic example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Julia4ML_GA\n\n# Easiest Usage Example: Solve a predefined example\n# rosenbrock takes to arguments (a, b). Solution at (a, a^2)\nbest_solution = Julia4ML_GA.solve_rosenbrock(4, 100)\nprintln(best_solution) # Should print roughly the following vector: [4, 16] \n\n# More elaborate Example: Define Fitness function and select appropriate genetic methods\n# starting population initialized with zeros\nstarting_population = [[0.0, 0.0] for i in 1:100]\n\n# rosenbrock function as the fitness function. Solution at (1, 1)\nfitness_function = x->(1-x[1])^2 +100*(x[2]-x[1]^2)^2\n\n# setting population size manually (default is 50), needs to be the same size as starting_population\nga_instance = Julia4ML_GA.GeneticAlgorithm(populationSize=100, \n        selection=roulette_wheel_inv,\n        mutation=gaussian_displacement,\n        crossover=k_point)\n\n# 1000 iterations containing crossover, mutation, evaluation, and selection to be performed\niterations=1000\n\n# Execute optimization process\nresult = Julia4ML_GA.optimize(starting_population,fitness_function,ga_instance;iterations)\n\nprintln(Julia4ML_GA.argmin(result)) # Should print roughly the vector: [1, 1]","category":"page"}]
}
